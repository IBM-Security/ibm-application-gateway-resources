# coding: utf-8

"""
    IBM Application Gateway Configuration Specification (OpenAPI)

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 21.12
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

class ResourceServerPersistentConnections(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'max_cache_size': 'float',
        'connection_timeout': 'float'
    }

    attribute_map = {
        'max_cache_size': 'max_cache_size',
        'connection_timeout': 'connection_timeout'
    }

    def __init__(self, max_cache_size=0, connection_timeout=5):  # noqa: E501
        """ResourceServerPersistentConnections - a model defined in OpenAPI"""  # noqa: E501

        self._max_cache_size = None
        self._connection_timeout = None
        self.discriminator = None

        if max_cache_size is not None:
            self.max_cache_size = max_cache_size
        if connection_timeout is not None:
            self.connection_timeout = connection_timeout

    @property
    def max_cache_size(self):
        """Gets the max_cache_size of this ResourceServerPersistentConnections.  # noqa: E501

        The maximum number of persistent connections which will be stored in the cache for future use.  Connections with resource servers will be cached for future use unless the configured limit is reached, or the `connection: close` header is received in the HTTP response.  Please note that if enabled there is the potential for different user sessions to use the same connection when processing requests.  To disable the persistent connection functionality simply specify a value of 0.   # noqa: E501

        :return: The max_cache_size of this ResourceServerPersistentConnections.  # noqa: E501
        :rtype: float
        """
        return self._max_cache_size

    @max_cache_size.setter
    def max_cache_size(self, max_cache_size):
        """Sets the max_cache_size of this ResourceServerPersistentConnections.

        The maximum number of persistent connections which will be stored in the cache for future use.  Connections with resource servers will be cached for future use unless the configured limit is reached, or the `connection: close` header is received in the HTTP response.  Please note that if enabled there is the potential for different user sessions to use the same connection when processing requests.  To disable the persistent connection functionality simply specify a value of 0.   # noqa: E501

        :param max_cache_size: The max_cache_size of this ResourceServerPersistentConnections.  # noqa: E501
        :type: float
        """
        if (max_cache_size is not None and max_cache_size < 0):  # noqa: E501
            raise ValueError("Invalid value for `max_cache_size`, must be a value greater than or equal to `0`")  # noqa: E501

        self._max_cache_size = max_cache_size

    @property
    def connection_timeout(self):
        """Gets the connection_timeout of this ResourceServerPersistentConnections.  # noqa: E501

        The maximum number of seconds a persistent connection can remain idle in the cache before the connection is cleaned up and closed by the IAG.  This value should be lower than the configured maximum connection lifetime for the resource server. This behaviour is controlled for the Apache Web server, as an example only, by the KeepAliveTimeout configuration entry.   # noqa: E501

        :return: The connection_timeout of this ResourceServerPersistentConnections.  # noqa: E501
        :rtype: float
        """
        return self._connection_timeout

    @connection_timeout.setter
    def connection_timeout(self, connection_timeout):
        """Sets the connection_timeout of this ResourceServerPersistentConnections.

        The maximum number of seconds a persistent connection can remain idle in the cache before the connection is cleaned up and closed by the IAG.  This value should be lower than the configured maximum connection lifetime for the resource server. This behaviour is controlled for the Apache Web server, as an example only, by the KeepAliveTimeout configuration entry.   # noqa: E501

        :param connection_timeout: The connection_timeout of this ResourceServerPersistentConnections.  # noqa: E501
        :type: float
        """
        if (connection_timeout is not None and connection_timeout < 0):  # noqa: E501
            raise ValueError("Invalid value for `connection_timeout`, must be a value greater than or equal to `0`")  # noqa: E501

        self._connection_timeout = connection_timeout

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ResourceServerPersistentConnections):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, ResourceServerPersistentConnections):
            return True

        return self.to_dict() != other.to_dict()
