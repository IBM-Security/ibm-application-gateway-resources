# coding: utf-8

"""
    IBM Application Gateway Configuration Specification (OpenAPI)

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 21.04
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

class Policies(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'http_transformations': 'PoliciesHttpTransformations',
        'cors': 'list[PoliciesCors]',
        'rate_limiting': 'list[PoliciesRateLimiting]',
        'content_injection': 'list[PoliciesContentInjection]',
        'authorization': 'list[PoliciesAuthorization]'
    }

    attribute_map = {
        'http_transformations': 'http_transformations',
        'cors': 'cors',
        'rate_limiting': 'rate_limiting',
        'content_injection': 'content_injection',
        'authorization': 'authorization'
    }

    def __init__(self, http_transformations=None, cors=None, rate_limiting=None, content_injection=None, authorization=None):  # noqa: E501
        """Policies - a model defined in OpenAPI"""  # noqa: E501

        self._http_transformations = None
        self._cors = None
        self._rate_limiting = None
        self._content_injection = None
        self._authorization = None
        self.discriminator = None

        if http_transformations is not None:
            self.http_transformations = http_transformations
        if cors is not None:
            self.cors = cors
        if rate_limiting is not None:
            self.rate_limiting = rate_limiting
        if content_injection is not None:
            self.content_injection = content_injection
        if authorization is not None:
            self.authorization = authorization

    @property
    def http_transformations(self):
        """Gets the http_transformations of this Policies.  # noqa: E501


        :return: The http_transformations of this Policies.  # noqa: E501
        :rtype: PoliciesHttpTransformations
        """
        return self._http_transformations

    @http_transformations.setter
    def http_transformations(self, http_transformations):
        """Sets the http_transformations of this Policies.


        :param http_transformations: The http_transformations of this Policies.  # noqa: E501
        :type: PoliciesHttpTransformations
        """

        self._http_transformations = http_transformations

    @property
    def cors(self):
        """Gets the cors of this Policies.  # noqa: E501

        The reverse proxy can support cross-origin resource sharing with CORS aware clients. Each defined policy must at a minimum contain:   * name   * method   * policy:allow_origins  This entry is an array and can be used to specify multiple CORS policies.  Example: policies:   cors:     - name: cors_policy_A       host: www.test.com       paths:         - \"/test\"         - \"/development\"       method: GET       policy:         allow_origins:           - www.test.com           - www.example.com         handle_pre_flight: true         allow_headers:           - test_header           - test_header2         max_age: 600         allow_methods:           - update           - create         allow_credentials: true         expose_headers:           - test_header           - test_header2   # noqa: E501

        :return: The cors of this Policies.  # noqa: E501
        :rtype: list[PoliciesCors]
        """
        return self._cors

    @cors.setter
    def cors(self, cors):
        """Sets the cors of this Policies.

        The reverse proxy can support cross-origin resource sharing with CORS aware clients. Each defined policy must at a minimum contain:   * name   * method   * policy:allow_origins  This entry is an array and can be used to specify multiple CORS policies.  Example: policies:   cors:     - name: cors_policy_A       host: www.test.com       paths:         - \"/test\"         - \"/development\"       method: GET       policy:         allow_origins:           - www.test.com           - www.example.com         handle_pre_flight: true         allow_headers:           - test_header           - test_header2         max_age: 600         allow_methods:           - update           - create         allow_credentials: true         expose_headers:           - test_header           - test_header2   # noqa: E501

        :param cors: The cors of this Policies.  # noqa: E501
        :type: list[PoliciesCors]
        """

        self._cors = cors

    @property
    def rate_limiting(self):
        """Gets the rate_limiting of this Policies.  # noqa: E501

        The gateway can apply rate limiting to incoming requests. This entry defines the rate limiting policies and where they will be applied. Refer to the documentation for information about how to author a rate-limiting policy. This entry is an array and can be used to define multiple policies.  Example: policies:   rate_limiting:     - name: rate_policy_A       methods:         - GET         - POST       paths:         - \"/test*\"         - \"/release*\"       rule: |         ip: true         capacity: 3         interval: 60         reaction: TEMPLATE   # noqa: E501

        :return: The rate_limiting of this Policies.  # noqa: E501
        :rtype: list[PoliciesRateLimiting]
        """
        return self._rate_limiting

    @rate_limiting.setter
    def rate_limiting(self, rate_limiting):
        """Sets the rate_limiting of this Policies.

        The gateway can apply rate limiting to incoming requests. This entry defines the rate limiting policies and where they will be applied. Refer to the documentation for information about how to author a rate-limiting policy. This entry is an array and can be used to define multiple policies.  Example: policies:   rate_limiting:     - name: rate_policy_A       methods:         - GET         - POST       paths:         - \"/test*\"         - \"/release*\"       rule: |         ip: true         capacity: 3         interval: 60         reaction: TEMPLATE   # noqa: E501

        :param rate_limiting: The rate_limiting of this Policies.  # noqa: E501
        :type: list[PoliciesRateLimiting]
        """

        self._rate_limiting = rate_limiting

    @property
    def content_injection(self):
        """Gets the content_injection of this Policies.  # noqa: E501

        The gateway can inject content into responses. This entry defines the content and when injection should take place. Content injection is performed based on the request path and a specific location within the response. This entry is an array and can define multiple content injection points.  Example: policies:   content_injection:     - name: content_injection_1       paths:         - \"/test\"         - \"/test2\"       location: \"<h3>*\"       content: |         <hr/>         <h4>Add heading4 after heading3</h4>         <hr/>   # noqa: E501

        :return: The content_injection of this Policies.  # noqa: E501
        :rtype: list[PoliciesContentInjection]
        """
        return self._content_injection

    @content_injection.setter
    def content_injection(self, content_injection):
        """Sets the content_injection of this Policies.

        The gateway can inject content into responses. This entry defines the content and when injection should take place. Content injection is performed based on the request path and a specific location within the response. This entry is an array and can define multiple content injection points.  Example: policies:   content_injection:     - name: content_injection_1       paths:         - \"/test\"         - \"/test2\"       location: \"<h3>*\"       content: |         <hr/>         <h4>Add heading4 after heading3</h4>         <hr/>   # noqa: E501

        :param content_injection: The content_injection of this Policies.  # noqa: E501
        :type: list[PoliciesContentInjection]
        """

        self._content_injection = content_injection

    @property
    def authorization(self):
        """Gets the authorization of this Policies.  # noqa: E501

        The gateway can apply authorization rules to incoming requests. This entry defines a list of matching requests, rules and actions to perform if matches are found. The rules can be either:   * Defined directly here in an entry.   * Defined in the authorization section and reference by name here in an entry.  This entry defines authorization rules directly. There are also two pre-defined rules which can be used:   * \"anyuser\" : Which allows access to any user, even if they are not authenticated.   * \"anyauth\" : Which allows access to any authenticated user.   Example: policies:   authorization:     - name: policyA       host: www.test.com       paths:         - /test*       methods:         - GET         - POST       rule: (any groupIds = \"administrator\")       action: permit      - name: policyB       host: www.example.com       paths:         - /example*       methods:         - DELETE       rule: anyuser       action: obligate       obligation:         oidc:           acr_values: \"administrator mfa\"           prompt: login      - name: mfa_required       rule: 'acr = \"urn:ibm:security:policy:id:2\"'       paths:         - \"/sensitive\"       action: \"permit\"      - name: mfa_required_obligate       rule: 'acr != \"urn:ibm:security:policy:id:2\"'       paths:         - \"/sensitive\"       action: \"obligate\"       obligation:         oidc:           acr_values: \"urn:ibm:security:policy:id:2\"           prompt: \"login\"      - name: eula_not_accepted       rule: 'eula != \"true\"'       paths:         - \"/application/*\"       action: \"obligate\"       obligation:         redirect_url: \"/eula/landing?origin=%URL%&user=%CREDATTR{preferred_username}%&proxy=%HTTPHDR{x-ibm-proxy}%\"   # noqa: E501

        :return: The authorization of this Policies.  # noqa: E501
        :rtype: list[PoliciesAuthorization]
        """
        return self._authorization

    @authorization.setter
    def authorization(self, authorization):
        """Sets the authorization of this Policies.

        The gateway can apply authorization rules to incoming requests. This entry defines a list of matching requests, rules and actions to perform if matches are found. The rules can be either:   * Defined directly here in an entry.   * Defined in the authorization section and reference by name here in an entry.  This entry defines authorization rules directly. There are also two pre-defined rules which can be used:   * \"anyuser\" : Which allows access to any user, even if they are not authenticated.   * \"anyauth\" : Which allows access to any authenticated user.   Example: policies:   authorization:     - name: policyA       host: www.test.com       paths:         - /test*       methods:         - GET         - POST       rule: (any groupIds = \"administrator\")       action: permit      - name: policyB       host: www.example.com       paths:         - /example*       methods:         - DELETE       rule: anyuser       action: obligate       obligation:         oidc:           acr_values: \"administrator mfa\"           prompt: login      - name: mfa_required       rule: 'acr = \"urn:ibm:security:policy:id:2\"'       paths:         - \"/sensitive\"       action: \"permit\"      - name: mfa_required_obligate       rule: 'acr != \"urn:ibm:security:policy:id:2\"'       paths:         - \"/sensitive\"       action: \"obligate\"       obligation:         oidc:           acr_values: \"urn:ibm:security:policy:id:2\"           prompt: \"login\"      - name: eula_not_accepted       rule: 'eula != \"true\"'       paths:         - \"/application/*\"       action: \"obligate\"       obligation:         redirect_url: \"/eula/landing?origin=%URL%&user=%CREDATTR{preferred_username}%&proxy=%HTTPHDR{x-ibm-proxy}%\"   # noqa: E501

        :param authorization: The authorization of this Policies.  # noqa: E501
        :type: list[PoliciesAuthorization]
        """

        self._authorization = authorization

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Policies):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, Policies):
            return True

        return self.to_dict() != other.to_dict()
